<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&display=swap" rel="stylesheet">
</head>
<body onload="Load()" onkeypress="move(event)">
	<canvas width="900" height="600" id="canvas" onmousemove="getMousePos(event)"> mousedown="</canvas>
</body>
<script>
//non gameplay variables
var mouseDown = [0, 0, 0, 0, 0, 0, 0, 0, 0],mouseDownCount = 0;
var map //height map
var avg = 5 //how many times times to avg-ing (5 meaning set to avg every 5 updates)
var heatMap //heat map
var canvas = document.getElementById("canvas")
var ctx = canvas.getContext("2d") //rendering
var max=0,min=0,heatMax=0,heatMin=0 //kinda useless (dont delete)
var width = 200,height = 200 //width and height of map
var times = 0 //kinda useless (dont delete)


var objectMap
var seed = Math.round(Math.random()*2**16) //seed
var day = 0
var hr = 6
var attackDuration = 0 //animation
var mousePos = {}
var particles = []
var texts = []
var projs = []
var drops = []
var sprite = {
	player: new Image(),
	object: new Image(),
	rick: new Image(), 
}
sprite.player.src = "player.png"
sprite.object.src = "object.png"
sprite.rick.src = "rick.png"
var items = [
	{},
	{name:"Wood",minDamage:2,maxDamage:3,atkSpeed:1,},
]
var inventory = [
	[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],
	[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],
	[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],
	[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],
	[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],
]
var player = {
	pos: [],
	stats: {
                test: 0.04,
		hp: 100,
		mhp: 100,
		stamina: 100,
		defense: 20,
		attackSpeed: 20,
		reach: 40,
	},
	attackCooldown: 0,
	powerups: [],
}
function updateStats() {

}
function attack() {
	var rotation = -Math.atan2(mousePos.x-450,mousePos.y-330)+Math.PI
	var x2 = -4
	while (x2<=4) {
		var y2 = -4
		while (y2<=4) {
                        if (circleCollision(player.pos[0]+0.5+51/60*Math.sin(rotation), player.pos[1]+0.5-51/60*Math.cos(rotation), player.stats.reach/60, player.pos[0]+0.5+x2, player.pos[1]+0.5+y2, Math.SQRT1_2)) {
                                objectMap[player.pos[0]+x2][player.pos[1]+y2][1] -= 2
				switch (objectMap[player.pos[0]+x2][player.pos[1]+y2][0]) {
					case 1: 
					        createParticles(player.pos[0]+x2+0.4, player.pos[1]+y2+0.4, 
						player.pos[0]+x2+0.6, player.pos[1]+y2+0.6
					        ,[0,2] ,[0.00075,10], -0.1, -0.1, 0.1, 0.1, [92,66,8,255], 
						0.04, 0.05, 6, 11, 24, 26, 0.86, 0.89)
					break;//tree
					case 2:
						createParticles(player.pos[0]+x2+0.4, player.pos[1]+y2+0.4, 
						player.pos[0]+x2+0.6, player.pos[1]+y2+0.6
					        ,[0,2] ,[0.00075,10], -0.1, -0.1, 0.1, 0.1, [104,104,104,255], 
						0.04, 0.05, 6, 11, 24, 26, 0.86, 0.89)
					break;//stone
					case 3:
						createParticles(player.pos[0]+x2+0.4, player.pos[1]+y2+0.4, 
						player.pos[0]+x2+0.6, player.pos[1]+y2+0.6
					        ,[0,2] ,[0.00075,10], -0.1, -0.1, 0.1, 0.1, [104,104,104,255], 
						0.04, 0.05, 5, 8, 24, 26, 0.86, 0.89)
						createParticles(player.pos[0]+x2+0.4, player.pos[1]+y2+0.4, 
						player.pos[0]+x2+0.6, player.pos[1]+y2+0.6
					        ,[0,2] ,[0.00075,10], -0.1, -0.1, 0.1, 0.1, [145,51,54,255], 
						0.04, 0.05, 1, 3, 24, 26, 0.86, 0.89)
					break;//copper ore
				}
				if (objectMap[player.pos[0]+x2][player.pos[1]+y2][0] > 0) {
                                        texts.push(JSON.parse(JSON.stringify({
                                                x: player.pos[0]+x2+0.5,
					        y: player.pos[1]+y2+0.5,
					        dx: Math.random()/5-0.1,
					        dy: 0.15,
					        fadeSpeed: 10,
					        color: [255, 255, 255, 255],
					        content: 2,
				        })))
				}
			}  
			y2++
		}
		x2++
	}
}
function update() {
	if (times>81) {
		var x=-20
	        while (x <= 20) {
		        var y = -20
		        while (y <= 20) {
		        	var x2 = Math.min(Math.max(player.pos[0] + x, 0), 799), y2 = Math.min(Math.max(player.pos[1] + y, 0), 799)
                                if (objectMap[x2][y2][1] <= 0) {
					switch (objectMap[x2][y2][0]) {
                                                case 1: spawnItems([ [1, 3, 5]          ], 1, x2+0.5, y2+0.5) ;break;
						case 2: spawnItems([ [2, 3, 5]          ], 1, x2+0.5, y2+0.5) ;break;
						case 3: spawnItems([ [3, 2, 3], [2, 80] ], 1, x2+0.5, y2+0.5) ;break;
					}
                                        objectMap[x2][y2] = [0,0,0]
				}
		        	y++
		        }
		        x++
	        }
                player.stats.stamina=Math.min(player.stats.stamina+0.25,100)
		player.attackCooldown < 150/player.stats.attackSpeed ? player.attackCooldown++ : 0
	        hr += 0.002
	        hr = hr.toFixed(4)
	        hr %= 24
	        if (hr==0) day++
		if (mouseDown[0]&&player.attackCooldown>=150/player.stats.attackSpeed) {
			player.attackCooldown %= 150/player.stats.attackSpeed
			attackDuration = 5
			attack()
		}
	        spawnObject()
	        render()
	    
	}
}
function spawnObject() {
	var spwn = [Math.round(Math.random()*798),Math.round(Math.random()*798)]
	var dist = Math.abs(player.pos[0]-spwn[0])+Math.abs(player.pos[1]-spwn[1])
	var a = 0
	var toSpawn = parseInt(weighted_random({
		"1": 20,
		"2": 15,
		"3": 10,
	}))
	var hp = [0,10,25,40][toSpawn]
	while ((dist<25||dist>250||objectMap[spwn[0]][spwn[1]][0]!=0||map[spwn[0]][spwn[1]]<0.3)&&a<100) {
                spwn = [Math.round(Math.random()*798),Math.round(Math.random()*798)]
		dist = Math.abs(player.pos[0]-spwn[0])+Math.abs(player.pos[1]-spwn[1])
		a++
	}
	a<100 ? objectMap[spwn[0]][spwn[1]] = [toSpawn,hp,hp] : 0
}
function render() {
        ctx.clearRect(0,0,900,600)
        var heat = heatMax - heatMin
        var height = max - min
        var x=0,p
        while (x<15) {
                var y=0	
	        while (y<10) {
			var x2 = x+player.pos[0]-7
			var y2 = y+player.pos[1]-5
                        if (x2<800&&x2>-1&&y2<800&&y2>-1) {
				ctx.fillStyle="hsl("+ 
				(220-(220*(map[x2][y2]-min)/height))
				+",100%,"+17.5*(Math.cos(hr*Math.PI/12+Math.PI)+1.6)+"%)"
				ctx.fillRect( x * 60 , y * 60  , 60 , 60)                             
			} else {
				ctx.fillStyle="black"
				ctx.fillRect( x * 60 , y * 60 , 60 , 60)  
			}                       
                        
			y++
		}
	        x++
        }
	var x=0
	while (x<15) {
                var y=0	
	        while (y<10) {
			var x2 = x+player.pos[0]-7
			var y2 = y+player.pos[1]-5
                        if (x2<800&&x2>-1&&y2<800&&y2>-1) {
				if (objectMap[x2][y2][0] > 0) {
                                        ctx.drawImage(sprite.object,objectMap[x2][y2][0]*60-60,0,60,60,x*60,y*60,60,60)
				}
				if (objectMap[x2][y2][0] > 0 && Math.abs(x-7)+Math.abs(y-5)<=5) {
                                        ctx.fillStyle = "#f00"; ctx.fillRect(x*60, y*60-10, 60, 4)
					ctx.fillStyle = "#0f0"; ctx.fillRect(x*60, y*60-10, 60*Math.max(0, objectMap[x2][y2][1]/objectMap[x2][y2][2]), 4)
				}                      
			}
			y++
		}
	        x++
        }
	ctx.fillStyle = "white"
	ctx.font = "17px Roboto"
	ctx.fillText(player.pos[0]+", "+player.pos[1],40,40)
	var a = Math.floor((hr%1*60)).toString().length<2?"0"+Math.floor(hr%1*60):Math.floor(hr%1*60)
	ctx.fillText(Math.floor(hr)+":"+a,120,40) 
	ctx.translate(450,330)
	ctx.rotate(-Math.atan2(mousePos.x-450,mousePos.y-330)+Math.PI)
	/*ctx.beginPath();var s = ((mousePos.x-450)**2+(mousePos.y-330)**2)**0.5;ctx.moveTo(x3+450,y3+330);ctx.lineTo(450+x3*2,330+y3*2);ctx.stroke();ctx.closePath() ;ctx.strokeStyle="#000000"*/
	/*ctx.beginPath();ctx.arc(-1,-31,player.stats.reach,0,7);ctx.strokeStyle="#ff0000";ctx.stroke();ctx.closePath() */
	ctx.drawImage(sprite.player,-30,-30)
	ctx.setTransform(1,0,0,1,0,0)
	for (p in drops) {
		ctx.drawImage(sprite.object,(drops[p].id-1)%2*60, Math.floor((drops[p].id-1)/2)*60, 60, 60, (drops[p].x-player.pos[0]+20/3)*60, (drops[p].y-player.pos[1]+14/3)*60, 40, 40)
		drops[p].x += drops[p].dx
		drops[p].y += drops[p].dy
		drops[p].dx *= drops[p].friction; drops[p].dy *= drops[p].friction
		if (circleCollision(drops[p].x,drops[p].y,1.1/3*Math.SQRT2,player.pos[0]+0.5,player.pos[1]+0.5,Math.SQRT1_2)) {
			drops[p].x = -100
			var j
			for (j in inventory) {
				if (inventory[j][0] == drops[p].id) {
					inventory[j][1]++
					break;
				}
				else if (inventory[j][0] == 0) {
					inventory[j][1]++ 
					inventory[j][0] = drops[p].id
					break;
				}
                                if (j >= 8) break;
			}
		}
	}
	drops = drops.filter(a => a.x>-1)
	//ctx.arc(450+51*Math.sin(-Math.atan2(mousePos.x-450,mousePos.y-330)+Math.PI),330-51*Math.cos(-Math.atan2(mousePos.x-450,mousePos.y-330)+Math.PI),40,0,7)
	for (p in particles) {
		var e = 0
		while (e < particles[p].type.length) {
                        switch (particles[p].type[e]) {
		        	case 0: particles[p].radius  +=                                  particles[p].amp[e]   ;break;//grow
		        	case 1: particles[p].radius   = Math.max(particles[p].radius   - particles[p].amp[e],0);break;//shrink
				case 2: particles[p].color[3] = Math.max(particles[p].color[3] - particles[p].amp[e],0);break;//fade
		        }
			e++
	        }
		ctx.beginPath()
		ctx.fillStyle = "rgba("+particles[p].color[0]+","+particles[p].color[1]+","+particles[p].color[2]+","+particles[p].color[3]/255+")"
		ctx.arc((particles[p].x-player.pos[0]+7)*60,(particles[p].y-player.pos[1]+5)*60, particles[p].radius*60, 0, 7)
		ctx.fill()
		ctx.closePath()
		particles[p].x += particles[p].dx; particles[p].y += particles[p].dy
		particles[p].dx *= particles[p].friction; particles[p].dy *= particles[p].friction
		particles[p].life--
	}
	for (p in texts) {
		//var timeExisted = (255-texts[p].color[3])/texts[p].fadeSpeed
		ctx.fillStyle = "rgba("+texts[p].color[0]+","+texts[p].color[1]+","+texts[p].color[2]+","+texts[p].color[3]/255+")"
		texts[p].color[3] -= texts[p].fadeSpeed
		texts[p].y -= texts[p].dy
		texts[p].x += texts[p].dx
		texts[p].dy -= 0.01
		ctx.fillText(texts[p].content, (texts[p].x-player.pos[0]+7)*60, (texts[p].y-player.pos[1]+5)*60)
	}
	particles = particles.filter(a=>a.life>0)
	ctx.fillStyle="rgba(0,0,0,0.3)";ctx.fillRect(700,450,200,150);ctx.fillRect(0,520,640,600)
	ctx.fillStyle="#f00";ctx.fillRect(710,460,180,25)
	ctx.fillStyle="#0f0";ctx.fillRect(710,460,Math.max(player.stats.hp/player.stats.mhp,0)*180,25)
	ctx.fillStyle="rgba(0,0,0,0.5)"; ctx.fillRect(710,495,180,25); ctx.fillRect(710,530,180,25); ctx.fillRect(710, 565, 180, 25)
	ctx.fillStyle="#ff0"
	ctx.fillRect(710,495,Math.min(Math.max(0, player.attackCooldown/150*player.stats.attackSpeed), 1)*180,25)
	ctx.fillStyle="#0ff";ctx.fillRect(710,565,player.stats.stamina/5*9,25)
	for (p in inventory) {
		//ctx.drawImage(sprite.rick, inventory[p][0]%2*60, Math.floor(inventory[p][0]/2)*60, 60, 60, 10+70*p, 530, 60, 60)
		ctx.drawImage(sprite.object, (inventory[p][0]-1)*60, 0, 60, 60, 10+70*p, 530, 60, 60)
		if (inventory[p][0]) {
			ctx.fillStyle = "#fff"
			ctx.font = "23px Roboto";
			ctx.fillText(inventory[p][1], 60+70*p, 595)
		}
		if(p >= 8)break;
	}
	//var sat = (100-(map[g][h]-min)*20/height)
            //ctx.fillStyle="hsl("+(360-((heatMap[g][h]-heatMin)/(heatMax-heatMin)*360))+",100%,"+((map[g][h]-min)/(max-min)*100)+"%)"
         /*   ctx.fillStyle="hsl(0,0%,"+((map[g][h]-min)/(max-min)*100)+"%)"
            ctx.fillRect(h*20+1200,g*20,20,20)
            ctx.fillStyle="hsl("+(220-((heatMap[g][h]-heatMin)/(heatMax-heatMin)*220))+",100%,60%)"
            ctx.fillRect(h*20+2400,g*20,20,20) */
}


//semi-stationary functions
function spawnItems(lootTable, times, x, y) {
	var loots = [],a
	//loottable format: [id n, chance n] or [id n, min n, max n]
	for (a in lootTable) {
		switch (lootTable[a].length) {
			case 2:
                                if (Math.random()<lootTable[a][1]/100) {
					loots.push( [lootTable[a][0], 1] )
				}
			break;
			case 3:
				loots.push( [lootTable[a][0], Math.round(randomRange(lootTable[a][1], lootTable[a][2]))] )
			break;
		}
	}
	console.log(loots)
	for (a in loots) {
		var b = 0
		while (b < loots[a][1]) {
			drops.push(JSON.parse(JSON.stringify({
				id: loots[a][0],
				x: x+0.5,
				y: y+0.5,
				dx: (Math.random() - 0.5) / 8,
				dy: (Math.random() - 0.5) / 8,
				friction: 0.97, 
			})))
			b++
		}
	}
}
function move(e) {
	var key = String.fromCharCode(e.which || e.keyCode).toLowerCase()
	var dir = [0,0]
	console.log(key)
	switch (key) {
                case "w": dir[1]--;break;
		case "a": dir[0]--;break;
		case "s": dir[1]++;break;
		case "d": dir[0]++;break;
	}
	if (player.stats.stamina>=5&&objectMap[player.pos[0]+dir[0]][player.pos[1]+dir[1]][0]==0) {
                if ( Math.random() < 1 - 
	        Math.min(Math.abs( map[player.pos[0]][player.pos[1]] - map[player.pos[0]+dir[0]][player.pos[1]+dir[1]] ) 
	        - player.stats.test, player.stats.test*2)/player.stats.test - Math.max( 0.3-map[player.pos[0]+dir[0]][player.pos[1]+dir[1]], 0 )*1.3
	        ) {
		player.pos[0] += dir[0]
		player.pos[1] += dir[1]
	        }
		player.stats.stamina-=5
	} //very fun to read i know
	render()
}
function createParticles(minX, minY, maxX, maxY, type, amp, minDX, minDY, maxDX, maxDY, color, radiusMin, radiusMax, minAmount, maxAmount, minLife, maxLife, frictionMin, frictionMax) {
	var i = Math.round(randomRange(minAmount, maxAmount))
	while (i>0) {
	        particles.push(JSON.parse(JSON.stringify({
	        	x: randomRange(minX, maxX),
	        	y: randomRange(minY, maxY),
	        	dx: randomRange(minDX, maxDX),
	        	dy: randomRange(minDY, maxDY),
	        	type: type,
			amp: amp,
	        	radius: randomRange(radiusMin, radiusMax),
			life: Math.round(randomRange(minLife, maxLife)),
			color: color,
			friction: randomRange(frictionMin, frictionMax),
	        })))
		i--
        }
}


//non gameplay functions
function repeatFunc(func,times) {
	var a=0
	while (a<times) {
		func()
		a++
	}
}
function Load() { //creates the map on load
    map = baseMap(width,height)
    heatMap = baseMap(width,height)
     /*81 == update times*/
    var ai
    /* for(ai in Array(8).fill(0)){
        createEntity(Math.random()*400+100,Math.random()*400+100, 40 , "phsads")
        createEntity(Math.random()*400+100,Math.random()*400+100, 220 , "phsads2")
    } */
}
document.body.onmousedown = function(evt) { 
  mouseDown[evt.button] = 1;
}
canvas.oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); }
document.body.onmouseup = function(evt) {
  mouseDown[evt.button] = 0;
}
function circleCollision(x1,y1,r1,x2,y2,r2) {
	return !(Math.sqrt( (x1-x2)**2+(y1-y2)**2 )>(r1+r2))
}
function weighted_random(a) {
	//a = {"2":weight}
	var b,c=0,d
	for (b in a) {
                c += a[b]
	}
	d = Math.random()*c
	for (b in a) {
		if (d < a[b]) {
			return b
		}
		d -= a[b]
	}
}
function getMousePos(event) {
    var rect = canvas.getBoundingClientRect();
    mousePos = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
} //stolem code boo boo boo boo boo boo
function randomRange(min, max) {return Math.random()*(max-min)+min}


//map generation
function random2(a) { //random function
    var r=[seed],h=0
    while (h<60) {
        h++
        r[h] = ( (a**1.1+seed**0.7-7*a+21)*r[h-1] )%100
    }
    return r[60]
}
function RNG(seed) {
  // LCG using GCC's constants
  this.m = random2(random2(52))*(2**31/100)
  this.a = random2(random2(81))*(2**15/100)
  this.c = random2(random2(43))*(2**12/100)

  this.state = seed ? seed : Math.floor(Math.random() * (this.m - 1));
}
RNG.prototype.nextInt = function() {
  this.state = (this.a * this.state + this.c) % this.m;
  return this.state;
}
RNG.prototype.nextFloat = function() {
  // returns in range [0,1]
  return this.nextInt() / (this.m - 1);
}
RNG.prototype.nextRange = function(start, end) {
  // returns in range [start, end): including start, excluding end
  // can't modulu nextInt because of weak randomness in lower bits
  var rangeSize = end - start;
  var randomUnder1 = this.nextInt() / this.m;
  return start + Math.floor(randomUnder1 * rangeSize);
}
RNG.prototype.choice = function(array) {
  return array[this.nextRange(0, array.length)];
}
var random = new RNG(seed)
function scaleConcat(array, factor) {
	let scaled = [];

	for(const row of array) {
		let x = [];

		for(const item of row)
			x = x.concat(Array(factor).fill(item));

		scaled = scaled.concat(Array(factor).fill(x));
	}

	return JSON.parse(JSON.stringify(scaled));
}
function baseMap(width,height) {
    var c,d,f=[]
    for (c in Array(height).fill(0)) {
        var e=[]
        for (d in Array(width).fill(0)) {
            e.push(0)
        }
        f.push(e)
    }
    return f
} //create the baseMap (a.k.a) map with width and height but no value
function maps() {
    var y1=0
    while (y1<height) {
        var x1=0
        while (x1<width) {
            map[y1][x1] += random.nextFloat()-0.5 //add a random value
            max=Math.max(map[y1][x1],max);min=Math.min(map[y1][x1],min) //change the min max
            x1++
        }
        y1++
    }
    times++
    if(times%avg==0) {
        var tempMap = JSON.parse(JSON.stringify(map))
        var i,j
        for (i in map) {
            for (j in map[i]) {
                var neigh=[],k=-1
                while (k<=1) {
                    var l=-1
                    while (l<=1) {
			var aby = k+(i*1)
			var abx = l+(j*1)
                        if (aby<height&&abx<width&&aby>-1&&abx>-1) {
                              neigh.push(map[aby][abx])
			}
                        l++
                    }
                    k++
                }
                var red = (a,b) => a+b
                tempMap[i][j] = neigh.reduce(red)/(neigh.length**(1-times/200))
            }
        } //avg things out
        map = tempMap
    }
    heatMaps() //update heatmaps
    if (times>81){clearInterval(intv);normalize()}
}
function heatMaps() {
    var y2=0
    while (y2<height) {
        var x2=0
        while (x2<width) {
            heatMap[y2][x2] += random.nextFloat()-0.5 //same as height maps
            heatMax=Math.max(heatMap[y2][x2],heatMax);heatMin=Math.min(heatMap[y2][x2],heatMin)
            x2++
        }
        y2++
    }
    if(times%avg==0) {
        var tempHMap = JSON.parse(JSON.stringify(heatMap)) //we copy the map and not make referecne senbfugeidfbhg
        var u,v
        for (u in heatMap) {
            for (v in heatMap[u]) {
                var neigh=[],w=-1
                while (w<=1) {
                    var x=-1
                    while (x<=1) {
			var aay = w+(u*1)
			var aax = x+(v*1)
                        if (aay<height&&aax<width&&aay>-1&&aax>-1) {
                                neigh.push(heatMap[aay][aax])
			}
                        x++
                    }
                    w++
                }
                var red = (a,b) => a+b
                tempHMap[u][v] = neigh.reduce(red)/(neigh.length**(1-times/200))
            }
        }
        heatMap = tempHMap 
    }
}
function normalize() {
        var y,z
        for (y in map) {
                for (z in map[y]) {
                        map[y][z] = (map[y][z]-min)/(max-min)
                        heatMap[y][z] = (heatMap[y][z]-heatMin)/(heatMax-heatMin)
                }
        }
        map = scaleConcat(map, 4)
        heatMap = scaleConcat(heatMap, 4)
	player.pos[0] = Math.round(Math.random()*798)
        player.pos[1] = Math.round(Math.random()*798)
        while (map[player.pos[0]][player.pos[1]]<0.3) {
	        player.pos[0] = Math.round(Math.random()*798)
	        player.pos[1] = Math.round(Math.random()*798)
        }
	objectMap = JSON.parse(JSON.stringify(Array(map.length).fill(Array(map[0].length).fill([0,0,0]))))
        max=1;min=0;heatMax=1;heatMin=0 //the tile with the highest smth will be set to 1, the lowest to 0 and everything else will be in between
	repeatFunc(spawnObject,1000)
}
var intv = setInterval(maps,20) //useless
setInterval(update,20)
</script>
</html>