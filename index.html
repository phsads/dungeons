<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap" rel="stylesheet">
</head>
<body onload="Load()" onkeydown="press(event)" style="text-align:center;background-color:black">
	<canvas width="900" height="600" id="canvas" onmousemove="getMousePos(event)" style="cursor:none"></canvas>
        <canvas width="1000" height="1" id="canvas2" hidden></canvas>
	<canvas width="800" height="800" id="canvas3"></canvas>
</body>
<script type="text/javascript" src="gen.js"></script>
<script type="text/javascript" src="functions.js"></script>
<script type="text/javascript" src="variables.js"></script>
<script>
function attack() {
	var rotation = -Math.atan2(mousePos.x-450,mousePos.y-330)+Math.PI
	var lifesteal = player.powerups.tooth*0.01
	var xpMult = player.powerups.book*.25+1
	var attackX = .5+51/60*Math.sin(rotation)+player.pos[0]
	var attackY = .5-51/60*Math.cos(rotation)+player.pos[1] 
	var x = -6
	while (x<=6) {
		var y = -6
		while (y<=6) {
                        if (circleCollision(attackX, attackY, player.stats.reach/60, .5+x+player.pos[0], .5+y+player.pos[1], Math.SQRT1_2)) {                           
				var x2 = player.pos[0]+x
				var y2 = player.pos[1]+y
				if (map[x2]==undefined||map[0][y2]==undefined)continue
				var obj = objectMap[x2][y2]
				
				//Damaging
				var damage = calculateDamage()

				//Tool strength difference
                                var toolStrengthDiff = items[inventory[holding][0]].toolStrength-toolStrengthReq[obj[0]]
				if (toolStrengthDiff>=0&&obj[0]) {
					
					//Tool strength buff
                                        damage[0] *= 1.1**toolStrengthDiff                             
					
					//Tool type buff
					damage[0] *= items[inventory[holding][0]].damageMult>>>bitCheck[obj[0]-1]&1
					damage[0] = Math.round(damage[0])

					//Dealing damage
					obj[1] -= damage[0]
				} else {damage[0] = 0}

				//Apply boosts
				if (damage[1]&&Math.random()<0.05*player.powerups.berserk) player.berserkActive = 20*player.powerups.berserk 
				player.stats.hp = Math.min(player.stats.mhp,player.stats.hp+damage[0]*lifesteal)
                                player.exp += damage[0]*xpMult
				
				//Apply effects
				screenShakeAmp = 10
				obj[4] = 4
				
				//Particles
			        for (let pr in particlesTo[obj[0]-1]) {
					var pTS = (particlesTo[obj[0]-1]||[[]])[pr].slice(0)
					if (pTS.length>0) {
						pTS[0]+=x2;pTS[1]+=y2
					        pTS[2]+=x2;pTS[3]+=y2
					        createParticles(...pTS)
					}
				}
				
				//Texts
				if (objectMap[x2][y2][0] > 0) {
					switch (damage[1]) {
						case 0:
                                                        texts.push({
                                                                x: x2+0.5,
					                        y: y2+0.5,
					                        dx: Math.random()/5-0.1,
					                        dy: 0.15,
					                        fadeSpeed: 8,
					                        color: [255, 255, 255, 255],
					                        content: damage[0],
				                        })
						break;
						case 1:
                                                        texts.push({
                                                                x: x2+0.5,
					                        y: y2+0.5,
					                        dx: Math.random()/5-0.1,
					                        dy: 0.15,
					                        fadeSpeed: 8,
					                        color: [255, 255, 0, 255],
					                        content: damage[0],
				                        })
						break;
						case 2:
                                                        texts.push({
                                                                x: x2+0.5,
					                        y: y2+0.5,
					                        dx: Math.random()/5-0.1,
					                        dy: 0.15,
					                        fadeSpeed: 8,
					                        color: [255, 0, 0, 255],
					                        content: damage[0],
				                        })
						break;
					}
				}			    
			}  
			y++
		}
		x++
	}

	//Damaging enemies
	for (x in enemies) {
		if (circleCollision(attackX, attackY, player.stats.reach/60,enemies[x].x+0.5,enemies[x].y+0.5,Math.SQRT1_2)) {
                        
			//Blood effect                     
			var bl = [[enemies[x].x+.5,enemies[x].y+.5,enemies[x].x+.5,enemies[x].y+.5,[1,3],[0.0005,-0.001],2.1415,4.1415,0.03,0.07,[255,0  ,0  ,255],"rgb",0.07,0.09,11,17,222,222,0.99,1],[enemies[x].x+.5,enemies[x].y+.5,enemies[x].x+.5,enemies[x].y+.5,[1,3],[0.0005,-0.001],2.1415,4.1415,0.03,0.07,[200  ,0  ,255],"rgb",0.07,0.09,11,17,222,222,0.99,1]]
			bl.forEach(a => createParticles(...a))
		        
			//Damaging       
			var damage = calculateDamage()
			damage[0] *= items[inventory[holding][0]].damageMult>>>0&1
			player.stats.hp = Math.min(player.stats.mhp,player.stats.hp+damage[0]*lifesteal*2)
			player.exp += 5*damage[0]*xpMult
			enemies[x].hp -= damage[0]

			//Spawning text
			switch (damage[1]) {
				case 0:
                                        texts.push({
                                                x: x2+0.5,
					                y: y2+0.5,
					                dx: Math.random()/5-0.1,
					                dy: 0.15,
					                fadeSpeed: 8,
					                color: [255, 255, 255, 255],
					                content: damage[0],
				                })
				break;
				case 1:
                                        texts.push({
                                                x: x2+0.5,
					        y: y2+0.5,
					        dx: Math.random()/5-0.1,
					        dy: 0.15,
					        fadeSpeed: 8,
					        color: [255, 255, 0, 255],
					        content: damage[0],
				        })
				break;
				case 2:
                                        texts.push({
                                                x: x2+0.5,
					        y: y2+0.5,
					        dx: Math.random()/5-0.1,
					        dy: 0.15,
					        fadeSpeed: 8,
					        color: [255, 0, 0, 255],
					        content: damage[0],
				        })
				break;
			}		        	      
		}
	}
}
function build() {
	//Stop if player mouse havent touched the screen yet
        if (mousePos.x==undefined) return

	//ID of object to build
	var buildID = items[inventory[holding][0]].buildID

	//Stop executing the code if there's nothing to build
	if (!buildID) return

        //Get the position on canvas to draw transparent version
	var tile = [Math.floor(mousePos.x/60),Math.floor(mousePos.y/60)]
	var x2 = tile[0]-7+player.pos[0]
	var y2 = tile[1]-5+player.pos[1]
	
	//Draw it
	var drawID = buildID-1
	ctx.drawImage(sprite.object,drawID%5*60,Math.floor(drawID/5)*60,60,60,tile[0]*60,tile[1]*60,60,60)
	
	//Make it transparent
	ctx.fillStyle = getColorFromHeight(map[x2][y2])+"1e"
	ctx.fillRect(tile[0]*60,tile[1]*60,60,60)

	//Draw red if cant build and green otherwise
	ctx.fillStyle = (objectMap[x2][y2][0] == 0 &&map[x2][y2]>0.3)? "#0000" : "rgba(255,0,0,0.5)"
	ctx.fillRect(tile[0]*60,tile[1]*60,60,60) //display transparent version of object
	
	//Placing action (when right click is held down)
	if (mouseDown[2]) {
                if (objectMap[x2][y2][0] == 0&&map[x2][y2]>0.3) {
                        objectMap[x2][y2] = [buildID, objectHP[buildID], objectHP[buildID], {}, 0]
			inventory[holding][1]--
		} 
	}
}
function calculateDamage() {

	//Updating stats
        updateStats()

	//Calculate damage mult
	var dmgMult = 1 , crit = 0

        //Item holding (for base damage)
	var i = items[inventory[holding][0]] 

	//5-leaf clover effect
	if (Math.random() < (player.powerups.clover2**0.6)/100) {
		dmgMult *= Math.log(player.powerups.clover2)*15;crit=2
	}

	//Critical hit
	if(Math.random() < player.stats.critChance/100) {
		dmgMult *= player.stats.critDamage/100+1;crit=1
	}

	//Dumbbell
	dmgMult *= player.powerups.dumbbell*0.04+1   

	//Return damage
        return [Math.round(randomRange(i.minDamage, i.maxDamage)*dmgMult),crit]
}
function craftItems(recipe, amnt) {
        var slotToPlace = 0, a, b, c, d=true, amount = amnt || 1
	//Amounts of items have (ID = index)
	var amounts = Array(items.length).fill(0)

	//Index of items have (ID = index)
	var IndxOnInv = Array(items.length).fill(-1)

	//Find recipe to craft 
	//if it's a number then recipes[num] otherwise the recipe
	var recipeToCraft = typeof recipe === "number" ? recipes[recipe] : recipe

	//Loop thru inventory slots to find slots where you could place the item
	while (slotToPlace < player.stats.inventorySlots) {
		var b = inventory[slotToPlace][0]

		//If inventory[b][0] is empty or the thing crafted then stop the loop
                b == recipeToCraft[2][0] || b == 0 ? a = true : 0
		if(a)break;

		//Otherwise continue
		slotToPlace++
	}

	//Stop checking if you can craft if there's no slot to place
	if(!a)return

	//Set the amounts and index
	for (c in inventory) {
		if(c>34)break;
                amounts[inventory[c][0]] += inventory[c][1]
		IndxOnInv[inventory[c][0]] = c
	}
	
	//Check if you have enough materials
	for (b in recipeToCraft[0]) {
                d = d && (amounts[recipeToCraft[0][b][0]] >= recipeToCraft[0][b][1] * amount)
	}
	
	//If not stop
	if(!d)return
	
	//Remove the mats needed
	for (b in recipeToCraft[0]) {
                inventory[IndxOnInv[recipeToCraft[0][b][0]]][1] -= recipeToCraft[0][b][1] * amount
		inventory[IndxOnInv[recipeToCraft[0][b][0]]][1] == 0 ? inventory[IndxOnInv[recipeToCraft[0][b][0]]][0] = 0 : 0
	}

	//Add the items crafted
	inventory[slotToPlace][0] = recipeToCraft[2][0]
	inventory[slotToPlace][1] += recipeToCraft[2][1] * amount
}
function createParticles(minX, minY, maxX, maxY, type, amp, minRad, maxRad, minSpeed, maxSpeed, color, colorType, radiusMin, radiusMax, minAmount, maxAmount, minLife, maxLife, frictionMin, frictionMax) {
	
	//Amounts of particles to spawn
	var i = Math.round(randomRange(minAmount, maxAmount))

	//Spawn the particles
	while (i--) {
		var rad = randomRange(minRad,maxRad)
		var speed = randomRange(minSpeed,maxSpeed)
	        particles.push(JSON.parse(JSON.stringify({
	        	x: randomRange(minX, maxX),
	        	y: randomRange(minY, maxY),
	        	dx: Math.sin(rad)*speed,
	        	dy: Math.cos(rad)*speed,
	        	type: type,
			amp: amp,
	        	radius: randomRange(radiusMin, radiusMax),
			life: Math.round(randomRange(minLife, maxLife)),
			color: color,
			colorType: colorType,
			friction: randomRange(frictionMin, frictionMax),
	        })))
        }
}
function getColorFromHeight(h) {
        if      (h< .1 )return "#003d4d"
	else if (h< .2 )return "#007a99"
	else if (h< .3 )return "#00ccff"
	else if (h< .4 )return "#dee600"
	else if (h<.62 )return "#009900"
	else if (h<.71 )return "#996633"
	else if (h<.75 )return "#666666"
	else            return "#e6e6e6"
}
function levelUp() {
	//while exp >= requirement
	while (player.exp>=(player.level+1)*200) {

		//Update level/exp
                player.level++
		player.exp-=player.level*200

		//Increase a random powerup
		var a = Object.keys(player.powerups)
		var b = a.length*Math.random()<<0
		while (a[b]=="berserkActive"||a[b]=="rubyPower") {
			b = a.length*Math.random()<<0
		}
		player.powerups[a[b]]++
	}
}
function move(dir) {
	//Position to move to
	var x2 = player.pos[0]+dir[0]
	var y2 = player.pos[1]+dir[1]

	//If you move out of bounds, stop
	if(map[x2]==undefined||map[0][y2]==undefined)return

	//Depends on destination, do things
	switch (objectMap[x2][y2][0]) {
		case 0:
		case 11:
		case 14:
		case 18:
		case 22:
		case 25:
		case 27:
		case 29:
		case 31:
		case 33:

		        //Move
		        player.pos[0] += dir[0]
		        player.pos[1] += dir[1]
		break;
		case 12:
		case 15:
		case 16:

		        //Crafting
			screen = "crafting"
			screenBonus[0] = objectMap[x2][y2][0]
		break;
		case 19:
		case 20:

			//Chest
			screen = "storage"
			screenBonus[0] = x2
			screenBonus[1] = y2
		break;
	}
}
function pickup(type) {
	var touched = -2
	
	//Each screen has a different GUI
	switch (type) {
		case "inventory":
		case "":

		        //Hotbar
			if (mousePos.y>=530&&mousePos.x<500&&mousePos.y<=590) {
                                if (mousePos.x%70-9>0) {
			                touched = Math.floor(mousePos.x/70)
		                }
	                }
		        
			//Inventory
			if (mousePos.y>=95&&mousePos.x>=65&&(mousePos.y%70<15||mousePos.y%70>24)&&(mousePos.x+5)%70<60&&mousePos.x<=575&&mousePos.y<=444&&screen=="inventory") {
                                touched = Math.floor((mousePos.x-65)/70)+(4-Math.floor((mousePos.y-95)/70))*7
	                }
	                
			//Dropping when clicked on an undefined spot
			if((touched==-2||touched>=player.stats.inventorySlots)||(mousePos.y<95||mousePos.x<65||mousePos.x>575||mousePos.y>444)) {
                                var rad = Math.atan2(mousePos.x-450,mousePos.y-330)
			        var speed = 0.18
			        if(out[0]){drops.push({
				        id: out[0],
				        x: player.pos[0]+0.5,
				        y: player.pos[1]+0.5,
				        dx: Math.sin(rad)*speed,
				        dy: Math.cos(rad)*speed,
				        friction: 0.97,
				        amount: out[1],
				        life: 19, 
			        })}
				out = [0,0]
			} 
			
			//Otherwise "transfer"
			else if (touched!==-2&&touched<player.stats.inventorySlots) {
                                var tempOut = inventory[touched].slice()
	                        inventory[touched] = out.slice()
	                        out = tempOut.slice() 
			}                       
		break;
		case "crafting":
			//Position
                        if (mousePos.x>=100&&mousePos.x<=790&&mousePos.y>=95&&mousePos.y<=305) {
		                if ((mousePos.x-40)%70<60&&(mousePos.y-35)%70<60) {
			                touched = Math.floor((mousePos.x-100)/70) + Math.floor((mousePos.y-95)/70)*10
		                }
	                }
			
			//Left arrow button
			else if (mousePos.x>=365&&mousePos.x<=405&&mousePos.y>=385&&mousePos.y<=425) {
				touched = -3
			} 

			//Right arrow button
			else if (mousePos.x>=495&&mousePos.x<=535&&mousePos.y>=385&&mousePos.y<=425) {
				touched = -4
			}
	                return touched
	 	break;
		case "storage":
			if (mousePos.x>=210&&mousePos.x<=690&&mousePos.y>=235&&mousePos.y<=365) {
                                if ((mousePos.x-150)%70<60&&(mousePos.y-175)%70<60) {
                                        touched = Math.floor((mousePos.x-210)/70) + Math.floor((mousePos.y-235)/70)*7
				}
			}
			return touched
		break;
	}
}
function press(e) {
	//Key pressed
	var key = e.which || e.keyCode

	//Do actions based on key pressed
	switch (key) {
		//Inventory hotkeys
		case 49 :             holding = 0; player.attackCooldown = 0;break;
		case 50 :             holding = 1; player.attackCooldown = 0;break;
		case 51 :             holding = 2; player.attackCooldown = 0;break;
		case 52 :             holding = 3; player.attackCooldown = 0;break;
		case 53 :             holding = 4; player.attackCooldown = 0;break;
		case 54 :             holding = 5; player.attackCooldown = 0;break;
		case 55 :             holding = 6; player.attackCooldown = 0;break;

		//Inventory (E)
		case 69 : case 101: screen=="inventory"?screen="":screen="inventory";break;
		
		//Crafting (R)
		case 82 : case 114: if (screen=="crafting") {
			screen="";screenBonus[0]=0;screenBonus[1]=1
		} else {
			screen="crafting";screenBonus[0]=0;screenBonus[1]=1
		}
		break;

		//smol map (M)
		case 77: case 109: renderMinimap() ;break;

		//ESC
		case 27: screen="";screenBonus[0]=0;screenBonus[1]=0;break;
	}
}
function render() {
	//Clear the canvas
	ctx.clearRect(-900,-600,1800,1200)

	//Apply screenshake
	var screenRad = Math.random()*Math.PI*2
	screenShakeAmp *= 0.5
	screenShake[0] = Math.round(Math.sin(screenRad)*screenShakeAmp)
	screenShake[1] = Math.round(Math.cos(screenRad)*screenShakeAmp)
	ctx.translate(screenShake[0],screenShake[1])

	//Smooth movement
	//ctx.translate(-player.fractionalPos[0]*60,-player.fractionalPos[1]*60)
	var p

	//Render map
	renderHeight()

	//Render projectiles
        p=-1;while (++p<projs.length) {
		projs[p].tick()
                

		//Render the projectile
		ctx.translate((projs[p].x-player.pos[0])*60+420,(projs[p].y-player.pos[1])*60+300)
		ctx.rotate(projs[p].rotation-Math.PI/4)
		ctx.drawImage(sprite.proj, 0, 0, 30, 30, -15, -15, 30, 30)

		//Reset transform
		ctx.setTransform(1,0,0,1,0,0)
		ctx.translate(screenShake[0],screenShake[1])
	        //ctx.translate(-player.fractionalPos[0]*60,-player.fractionalPos[1]*60)
	}
	
	//Render drops
	p=-1;while (++p<drops.length) {

		//Render the drops itself
		ctx.drawImage(sprite.items,drops[p].id%5*60, Math.floor(drops[p].id/5)*60, 60, 60, (drops[p].x-player.pos[0]+20/3)*60, (drops[p].y-player.pos[1]+14/3)*60, 40, 40)
		
		//Update the drop
		drops[p].x += drops[p].dx
		drops[p].y += drops[p].dy
		drops[p].dx *= drops[p].friction; drops[p].dy *= drops[p].friction
		drops[p].life--
		
		//Create rarity particles (emits particles based on rarity)
		var rarities = ["common","uncommon","rare", "epic", "mythical"]
		var pRC = {
			"common": [230, 230, 230, 100],
			"uncommon": [0, 127, 0, 100],
			"rare": [0, 0, 166, 100],
			"epic": [157, 30, 157, 100],
			"mythical": [145, 0, 0, 100],
		}
		if (Math.random()<0.01*2**rarities.indexOf(items[drops[p].id].rarity)) {
		        createParticles(drops[p].x, drops[p].y, drops[p].x, drops[p].y,
		        [2,0], [5,0.0025], 0, Math.PI*2, 0.03, 0.05, pRC[items[drops[p].id].rarity], 
		        "rgb", 0.003, 0.003, 1, 
		        1.5**rarities.indexOf(items[drops[p].id].rarity), 
		        20, 20, 0.98, 0.98)
		}
		
		//If collides with the player then pick it up if there's slots
		if (circleCollision(drops[p].x,drops[p].y,1/3*Math.SQRT2,player.pos[0]+0.5,player.pos[1]+0.5,Math.SQRT1_2)&&drops[p].life<=0) {
			var j
			for (j in inventory) {
				if (inventory[j][0] == drops[p].id) {
					inventory[j][1] += drops[p].amount
					drops[p].amount = 0
					break;
				}
				else if (inventory[j][0] == 0) {
					inventory[j][1] += drops[p].amount
					inventory[j][0] = drops[p].id
					drops[p].amount = 0
					break;
				}
                                if (j >= Math.min(34,player.stats.inventorySlots-1)) break;
			}
		}
	} 
	
	//Render particles
	p=-1;while (++p<particles.length) {

		//Go through properties of the particles and do stuff based on it
		var e = -1
		while (++e < particles[p].type.length) {
			var amp = particles[p].amp[e]
                        switch (particles[p].type[e]) {
		        	case 0: particles[p].radius  +=                              amp   ;break;//grow
		        	case 1: particles[p].radius   = Math.max(particles[p].radius-amp,0);break;//shrink
				case 2: particles[p].color[3] = particles[p].color[3]      - amp   ;break;//fade
				case 3: particles[p].dy      -=                              amp   ;break;//
		        }
	        }


		//Select the color
		switch (particles[p].colorType) {
			case "rgb": ctx.fillStyle = "rgba("+particles[p].color[0]+","+particles[p].color[1]+"," +particles[p].color[2]+"," +particles[p].color[3]/255+")";break;
		        case "hsl": ctx.fillStyle = "hsla("+particles[p].color[0]+","+particles[p].color[1]+"%,"+particles[p].color[2]+"%,"+particles[p].color[3]/255+")"
		}
		
		//Draw the particle
		ctx.beginPath()
		ctx.arc((particles[p].x-player.pos[0]+7)*60,(particles[p].y-player.pos[1]+5)*60, particles[p].radius*60, 0, 7)
		ctx.fill()
		ctx.closePath()

		//Update particles
		particles[p].x += particles[p].dx; particles[p].y += particles[p].dy
		particles[p].dx *= particles[p].friction; particles[p].dy *= particles[p].friction
		particles[p].life--
	}
	
	//Render damage text
	p=-1;while (++p<texts.length) {
		
		//Update the text
		texts[p].color[3] -= texts[p].fadeSpeed/4
		texts[p].y -= texts[p].dy
		texts[p].x += texts[p].dx
		texts[p].dy -= 0.005

		//Render the text
		ctx.fillStyle = "rgba("+texts[p].color[0]+","+texts[p].color[1]+","+texts[p].color[2]+","+texts[p].color[3]/255+")"
		ctx.fillText(texts[p].content, (texts[p].x-player.pos[0]+7)*60, (texts[p].y-player.pos[1]+5)*60)
	}
	
	//Filter off "dead" things
	projs = projs.filter(a => a.life>0)
	drops = drops.filter(a => a.x>-1&&a.amount>0)
	particles = particles.filter(a=>a.life>0)
	texts = texts.filter(a=>a.color[3]>0)

	//Render some more things
	renderObjects()
	renderEnemies()
	build()

	//Render the player in the middle of the screen (with rotation)
	ctx.setTransform(1,0,0,1,0,0)
	ctx.translate(screenShake[0],screenShake[1])
	ctx.translate(450,330)
	ctx.rotate(-Math.atan2(mousePos.x-450,mousePos.y-330)+Math.PI)
	ctx.drawImage(sprite.player,-30,-30)

	//Archived code
	/*ctx.fillStyle = "#ff0";ctx.lineWidth = 2;ctx.beginPath();ctx.arc(450,330,30,0,7);ctx.fill();ctx.stroke();ctx.closePath()*/
	/*ctx.beginPath();ctx.arc(450+51*Math.sin(-Math.atan2(mousePos.x-450,mousePos.y-330)+Math.PI),330-51*Math.cos(-Math.atan2(mousePos.x-450,mousePos.y-330)+Math.PI),player.stats.reach,0,7);ctx.stroke();ctx.closePath()*/
	/*ctx.beginPath();var s = ((mousePos.x-450)**2+(mousePos.y-330)**2)**0.5;ctx.moveTo(x3+450,y3+330);ctx.lineTo(450+x3*2,330+y3*2);ctx.stroke();ctx.closePath() ;ctx.strokeStyle="#000000";ctx.beginPath();ctx.arc(-1,-31,player.stats.reach,0,7);ctx.strokeStyle="#ff0000";ctx.stroke();ctx.closePath()*/
	
	//Render brightness
	ctx.setTransform(1,0,0,1,0,0)
	ctx.translate(screenShake[0],screenShake[1])
	renderBrightness()
	ctx.setTransform(1,0,0,1,0,0)

	//Render UI
	renderBars()
	renderGUI()
	renderPowerups()
	renderScreen()

	//Render other stuff
	ctx.font = "19px Roboto"
	ctx.textAlign = "center"
	renderInventory()
	renderCursor()
}
function renderBars() {
	//Bar area
	ctx.fillStyle="rgba(0,0,0,0.3)";ctx.fillRect(700,485,200,115)

	//HP bar
	ctx.fillStyle="#b00";ctx.fillRect(710,495,180,25)
	ctx.fillStyle="#0b0";ctx.fillRect(710,495,Math.max(player.stats.hp/player.stats.mhp,0)*180,25)
	
	ctx.fillStyle="rgba(0,0,0,0.8)"
	ctx.fillRect(710,530,180,25) //armor bar
	ctx.fillRect(710, 565, 180, 25) //stamina bar
	ctx.fillRect(0,520,500,80) //hotbar
	
	//Stamina bar
	ctx.fillStyle="#0cc";ctx.fillRect(710,565,player.stats.stamina/5*9,25)
	ctx.fillStyle="#fff";ctx.font = "21px Roboto";ctx.textAlign = "center"
	
	//HP bar number
        ctx.fillText(Math.floor(player.stats.hp)+" / "+player.stats.mhp,800,510)
	//Armor bar
	ctx.fillStyle="#ddd"

	//Damage reduction amount
	var dmgAfter = 100/(player.stats.defense+100)

	//Whatever this is
	ctx.fillRect(710,530,Math.max(0,-Math.log10(dmgAfter)%1*180),25)
	ctx.fillStyle = "#000"
	if(dmgAfter>0.0001)ctx.fillText((100-dmgAfter*100).toFixed(2)+"%",800,545)
	else ctx.fillText("1/"+(1/dmgAfter).toFixed(2),800,545)
}
function renderBrightness() {
	//Update the brightness before rendering
        updateBrightness()

	//Loop through an area around the player
	var x=-15
        while (x<=15) {
                var y=-10	
	        while (y<=10) {

			//Get the position
			var x2 = x+player.pos[0]
			var y2 = y+player.pos[1]

			//Render if it's in bounds
                        if (x2<map[0].length&&x2>-1&&y2<map.length&&y2>-1) {

				//Render brightness
				ctx.fillStyle = "rgba(0,0,0,"+Math.max(Math.min(1-brightnessMap[x2][y2],1),0)+")"
				ctx.fillRect( x * 60 + 420 , y * 60 + 300 , 60 , 60)                             
			}    
			y++
		}
	        x++
        }
}
function renderCursor() {
	ctx.fillStyle = "#fff9"

	//Render circl around mouse
        ctx.beginPath()
	ctx.arc(mousePos.x,mousePos.y,4,0,7)
	ctx.fill()
	ctx.closePath()

	//Attack bar
	ctx.fillStyle="#0009";ctx.fillRect(mousePos.x-18,mousePos.y+8,36,6)
	ctx.fillStyle="#fff9"; ctx.fillRect(mousePos.x-18,mousePos.y+8,Math.min(36,Math.max(0,player.attackCooldown/2.222)),6)
}
function renderEnemies() {
        var a = -1
	var shift = {
		"zombie": 30,
		"skeleton": 30,
	}
	var drawX = {
		"zombie": 0,
		"skeleton": 60,
	}
	var drawY = {
		"zombie": 0,
		"skeleton": 0,
	}      
	while (++a<enemies.length) {
		//Update the enemies
		enemies[a].tick()

		//Draw the enemies
		var tag = enemies[a].tag
		ctx.translate((enemies[a].x-player.pos[0]+8)*60-shift[tag],(enemies[a].y-player.pos[1]+6)*60-shift[tag])
		ctx.rotate(enemies[a].rotation)
		ctx.drawImage(sprite.enemies, drawX[tag], drawY[tag], 60, 60, 
		-30,-30,60,60)
		ctx.setTransform(1,0,0,1,0,0)
		ctx.translate(screenShake[0],screenShake[1])

	        //If enemy is kill then increase ruby power	
		if(enemies[a].hp<=0)player.powerups.rubyPower += player.powerups.ruby
	        
		//HP bar
		ctx.fillStyle = "#f00";ctx.fillRect((enemies[a].x-player.pos[0]+7)*60,(enemies[a].y-player.pos[1]+5)*60+10,60,5)
	        ctx.fillStyle = "#0f0";ctx.fillRect((enemies[a].x-player.pos[0]+7)*60,(enemies[a].y-player.pos[1]+5)*60+10,Math.max(0,enemies[a].hp/enemies[a].mhp*60),5)
		
		//Attack bar
		ctx.fillStyle = "#aaa";ctx.fillRect((enemies[a].x-player.pos[0]+7)*60,(enemies[a].y-player.pos[1]+5)*60-5,60,5)
		ctx.fillStyle = "#ff0";ctx.fillRect((enemies[a].x-player.pos[0]+7)*60,(enemies[a].y-player.pos[1]+5)*60-5,Math.max(0,enemies[a].cooldown/enemies[a].attackInterval*60),5)
	}

	//Filter off dead enemies
	enemies = enemies.filter(a => a.hp>0)
}
function renderGUI() {
	//Background
	ctx.fillStyle = "#000000a0"
	ctx.fillRect(0,240,130,120)

	//GUI icons
	ctx.drawImage(sprite.gui, 0 , 0, 30, 30, 0, 240, 30, 30)
	ctx.drawImage(sprite.gui, 30, 0, 30, 30, 0, 270, 30, 30)
	ctx.drawImage(sprite.gui, 60, 0, 30, 30, 0, 300, 30, 30)
	ctx.drawImage(sprite.gui, 90, 0, 30, 30, 0, 330, 30, 30)

	ctx.textAlign = "left";ctx.font="21px Roboto"
	
	//Time
	var time = Math.floor((hr%1*60)).toString().length<2?"0"+Math.floor(hr%1*60):Math.floor(hr%1*60)
	
	//Render values
	ctx.fillStyle = "rgb(195,195,195)";ctx.fillText(Math.floor(hr)+":"+time, 40, 257)
	ctx.fillStyle = "rgb(0,162,232)"  ;ctx.fillText(day, 40, 287)
	ctx.fillStyle = "rgb(34,177,76)"  ;ctx.fillText(Math.floor(player.exp)+"/"+(player.level+1)*200, 40, 317)
	ctx.fillStyle = "rgb(255,242,0)"  ;ctx.fillText("Level "+player.level, 40, 347) 
}
function renderHeight() {
	//Loop thruough
        var x=-15
        while (x<=15) {
                var y=-10	
	        while (y<=10) {
			var x2 = x+player.pos[0]
			var y2 = y+player.pos[1]
			//Color if in bounds, black if not
                        if (x2<map[0].length&&x2>-1&&y2<map.length&&y2>-1) {
				ctx.fillStyle = getColorFromHeight(map[x2][y2])
			} else {
				ctx.fillStyle="black"
			}                       
                        ctx.fillRect( x * 60 + 420, y * 60 +300, 60 , 60)  
			y++
		}
	        x++
        }
}
function renderInventory() {
	for (q in inventory) {
		//If past amount stop
		if(q*1 >= 35) break;

		//Render hotbar
                if (q*1 < 7) {
			//Background
			ctx.fillStyle = rarity_colors[items[inventory[q][0]].rarity]
			ctx.fillRect(10+70*q, 530, 60, 60)

			//Foreground
		        ctx.drawImage(sprite.items, inventory[q][0]%5*60, Math.floor( inventory[q][0]/5 )*60, 60, 60, 10+70*q, 530, 60, 60)
		        
			//Background darker when held
			ctx.fillStyle = "rgba(0, 0, 0, 0.25)"
			if (q==holding) ctx.fillRect(70*q+10, 530, 60, 60)       
			
			//Render text if not air
			if (inventory[q][0]) {
			        ctx.fillStyle = "#fff"
			        ctx.fillText(inventory[q][1], 40+70*q, 593)
		        }  
	        } 
		
		//Render inventory
		if (screen=="inventory") {
			if (q >= Math.min(player.stats.inventorySlots,35)) {
			} else {
				//Background
				ctx.fillStyle = rarity_colors[items[inventory[q][0]].rarity]
				ctx.fillRect(q%7*70+65, 375-Math.floor(q/7)*70, 60, 60)

				//Foreground
				ctx.drawImage(sprite.items, inventory[q][0]%5*60, Math.floor(inventory[q][0]/5)*60, 60, 60, q%7*70+65, 375-Math.floor(q/7)*70, 60, 60)
				
				//Darker if held
				ctx.fillStyle = "rgba(0, 0, 0, 0.25)"
				if (q==holding) ctx.fillRect(q%7*70+65, 375-Math.floor(q/7)*70, 60, 60)
				ctx.fillStyle = "#fff"
				
				//Render text if it's not air
				if(inventory[q][0])ctx.fillText(inventory[q][1], q%7*70+95, 438-Math.floor(q/7)*70)
			}
		}
	}

	//Render things holding
	if (out[0]!=0) {
		ctx.drawImage(sprite.items, out[0]%5*60, Math.floor( out[0]/5 )*60, 60, 60, mousePos.x-30, mousePos.y-30, 60, 60)
	        ctx.fillStyle = "#fff"
	        ctx.fillText(out[1], mousePos.x, mousePos.y+30)
	}
	if (screen!=="inventory")return

	//Armors shenanigans
	var touch = -2
	var armors = [23,35,46,58,73,88,99,112,122]
	if (click[0]) {
		if (mousePos.x>=560&&mousePos.x<=620&&mousePos.y>=165&&mousePos.y<=435) {
			if ((mousePos.y-165)%70<60) {
                                touch = Math.floor((mousePos.y-165)/70)
			}
		}
		if (touch>=0) {
			if (out[0]==0||armors.indexOf(out[0]-touch)!==-1) {
                                var tempOut = inventory[35][touch]
	                        inventory[35][touch] = out[0]
	                        out = [tempOut,1]
			}
		}
	}
	for (q in inventory[35]) {
		ctx.fillStyle = rarity_colors[items[inventory[35][q]].rarity]
		ctx.fillRect(560, 165+q*70, 60, 60)
		ctx.drawImage(sprite.items, inventory[35][q]%5*60, Math.floor(inventory[35][q]/5)*60, 60, 60, 560, 165+q*70, 60, 60)
	}
	
	//Show details ._.
	showDetails()
}
function renderMinimap() {
	
	//Buggy
	var a=0

	//Map
	var ctx3 = document.getElementById("canvas3").getContext("2d")
	while (a<map.length) {
		var b=0
		while (b<map.length) {
			ctx3.fillStyle = getColorFromHeight(map[a][b])
			ctx3.fillRect(b/2,a/2,1,1)
			b+=2
		}
		a+=2
	}

	//Player
	ctx3.fillStyle = "#f00"
	ctx3.beginPath()
	ctx3.arc(Math.floor(player.pos[0]/2),Math.floor(player.pos[1]/2),4,0,7)
	ctx3.fill()
	ctx3.closePath()
}
function renderObjects() {
	var x=-15
	while (x<=15) {
                var y=-10
	        while (y<=10) {
			var x2 = x+player.pos[0]
			var y2 = y+player.pos[1]
                        if (x2<map[0].length&&x2>-1&&y2<map.length&&y2>-1) {

				//Update storage for chests
				if (objectMap[x2][y2][0]==19&&objectMap[x2][y2][3].storage==undefined) {
					objectMap[x2][y2][3].storage = Array(7).fill([0,0]).map(copy)
				} else if (objectMap[x2][y2][0]==20&&objectMap[x2][y2][3].storage==undefined) {
					objectMap[x2][y2][3].storage = Array(14).fill([0,0]).map(copy)
				}

				//Torch particles effect
				if (objectMap[x2][y2][0]==23) {
					createParticles(0.35+x2,0.2 +y2,0.65+x2,0.4 +y2,[1,2],[0.0015,5],2.6415,3.6415,0.03,0.055,[255,40,40,255] ,"rgb",0.08,0.1 ,2,3,50,52,0.96,0.98)
				        createParticles(0.45+x2,0.35+y2,0.55+x2,0.55+y2,[1,2],[0.0015,5],2.6415,3.6415,0.03,0.055,[255,120,40,255],"rgb",0.07,0.09,1,2,50,52,0.96,0.98)
					createParticles(0.45+x2,0.35+y2,0.55+x2,0.55+y2,[1,2],[0.0015,5],2.6415,3.6415,0.03,0.055,[255,190,40,255],"rgb",0.05,0.07,1,2,50,52,0.96,0.98)
				}
				
				//Size
				var size = loglerp(20,60,objectMap[x2][y2][4]/10)

				//Render the object and increase size
				if (objectMap[x2][y2][0] > 0) {
                                        ctx.drawImage(sprite.object, (objectMap[x2][y2][0]-1)%5*60,Math.floor((objectMap[x2][y2][0]-1)/5)*60,60,60,x*60+(60-size)/2+420,y*60+(60-size)/2+300,size,size)
				        objectMap[x2][y2][4]++
				}

				//HP bar if close
				if (objectMap[x2][y2][0] > 0 && Math.abs(x)+Math.abs(y)<=4) {
                                        ctx.fillStyle = "#f00"; ctx.fillRect(x*60+420, y*60+290, 60, 4)
					ctx.fillStyle = "#0f0"; ctx.fillRect(x*60+420, y*60+290, 60*Math.max(0, objectMap[x2][y2][1]/objectMap[x2][y2][2]), 4)
				}                      
			}
			y++
		}
	        x++
        }
}
function renderPowerups() {
	//Background
	ctx.fillStyle="#000000a0";ctx.fillRect(750,0,150,120)
	
	//Change text
	ctx.textAlign = "center";ctx.fillStyle="#fff";ctx.font = "14px Roboto"
	
	//Whatever this is
	let index = ["dumbbell","box","rock","milk1","milk2","glove","clover1","taser","tooth","milk3","pill","milk4","quiver","drive","book","clover2","ruby","berserk","ring"]
	
	//Loop thru powerups
	for (const n in player.powerups) {
		//Dont render if amount is 0 or these 2 "powerups"
                if(!player.powerups[n]||n=="rubyPower"||n=="berserkActive")continue
	        
		//Index
		var q = index.indexOf(n)

		//Render
		ctx.drawImage(sprite.powerups, q%5*30, Math.floor(q/5)*30, 30, 30, 750+q%5*30, Math.floor(q/5)*30, 30, 30)
		ctx.fillText(player.powerups[n],q%5*30+765,Math.floor(q/5)*30+30)
	}
}
function renderScreen() {
	switch (screen) {
                case "inventory":
			//Background
			ctx.fillStyle="#000000a0"
			ctx.fillRect(55, 85, 780, 360)
		break;
		case "crafting":
			//Background
			ctx.fillStyle="#000000a0";ctx.fillRect(90, 85, 710, 360)
			ctx.textAlign="center";ctx.font = "21px Roboto"
			var recipesToIndex = []
			let k=-1
			//Get recipes to display
			while (++k<recipes.length) {
				let n = true,o = false,m=-1,l=-1
				while (++m<recipes[k][0].length) {
                                        if (!unlocked[recipes[k][0][m][0]]) {
						n = false
						break;
					}						     
				}
				while (++l<recipes[k][1].length) {
                                        if (recipes[k][1][l] == screenBonus[0]) {
					        o = true       
						break;
					}
				}
				if (n&&o) {
					recipesToIndex.push(k*1)
				}
			}
			
			//Render the recipes
			k=-1
			while (++k<recipesToIndex.length) {

				//Get recipe to display
				var toDisplay = recipes[recipesToIndex[k*1+screenBonus[1]*30]]
				
				//If there's no recipe or it's outside the screen then stop the loop
				if (k>29||toDisplay==undefined) break;

				//Background
				ctx.fillStyle = rarity_colors[items[toDisplay[2][0]].rarity]
				ctx.fillRect(100+k%10*70, Math.floor(k/10)*70+95, 60, 60)
				
				//Draw the crafted item
				ctx.drawImage(sprite.items, toDisplay[2][0]%5*60, Math.floor(toDisplay[2][0]/5)*60, 60, 60, 100+k%10*70, Math.floor(k/10)*70+95, 60, 60)
			}
                        
			//Items you have
			var itemsHave = Array(items.length).fill(0)                     
			
			//Update itemsHave
			for (k in inventory) {
				if(k==34)break;
                                itemsHave[inventory[k][0]] = inventory[k][1]
			}
			
			//If there's no recipe to render then that
			if (!recipesToIndex.length) {
				ctx.fillStyle="#fff";ctx.fillText("You should get some resources...",445, 265)	
		        } else {
				//Get the thing you're hovering over	     
			        var q = pickup("crafting")
			        if (q>-2&&q+screenBonus[1]*30<recipesToIndex.length) {
					q += screenBonus[1]*30
				        
					//Craft items if clicked
					if (click[0]) {
                                                craftItems(recipesToIndex[q+screenBonus[1]*30])
				        }

					//Render the materials needed
					for (k in recipes[recipesToIndex[q]][0]) {
						//Items needed
						var t = recipes[recipesToIndex[q]][0][k]
						
						//Rarity
                                                ctx.fillStyle = rarity_colors[items[t[0]].rarity]
						ctx.fillRect(100+70*k,305,60,60)
						
						//Draw it
						ctx.drawImage(sprite.items, t[0]%5*60, Math.floor(t[0]/5)*60, 60, 60, 100+k*70, 305, 60, 60)
					        
						//Colored text
						ctx.fillStyle = t[1] /*amt needed*/ <= itemsHave[t[0]] /*amt have*/ ? "#0f0" : "#f00"
						ctx.fillText(t[1],130+70*k,370)
					}
				//Arrows GUI
			        } else if (q==-3&&click[0]) {
                                        screenBonus[1]-- //<
				} else if (q==-4&click[0]) {
					screenBonus[1]++ //>
				}

				//Update page
				if(screenBonus[1]>=0)screenBonus[1] %= Math.ceil(recipesToIndex.length/30)
				else screenBonus[1] = Math.ceil(recipesToIndex.length/30)-1
			        
				//Change font
				ctx.font = "22px Roboto"
				ctx.textAlign = "center"
				ctx.fillStyle = "#fff"

				//Page number
				ctx.fillText("Page "+(screenBonus[1]+1), 450, 405)
				
				//Buttons
				ctx.fillStyle = "#000"
				ctx.fillRect(365,385,40,40);ctx.fillRect(495,385,40,40)
				
				ctx.fillStyle = "#fff"
				ctx.fillRect(370,390,30,30);ctx.fillRect(500,390,30,30)
				
				ctx.fillStyle="#000"
				ctx.font = "28px Roboto"
				ctx.fillText("<",385,407)
				ctx.fillText(">",515,407)
		        }                 
		break;
		case "storage":

			//Background
                        ctx.fillStyle="#000000a0"
			ctx.fillRect(200,225,500,150)
			
			//Loop through the storage
			for (let a in objectMap[screenBonus[0]][screenBonus[1]][3].storage) {
				
				//Item
				var item = objectMap[screenBonus[0]][screenBonus[1]][3].storage[a]
				
				//Rarity
				ctx.fillStyle = rarity_colors[items[item[0]].rarity]
				ctx.fillRect(a%7*70+210,Math.floor(a/7)*70+235,60,60)
				
				//Draw the item
				ctx.drawImage(sprite.items, item[0]%5*60, Math.floor(item[0]/5)*60, 60, 60, a%7*70+210, Math.floor(a/7)*70+235, 60, 60)
			       
				//Amount
				ctx.fillStyle = "#fff";ctx.textAlign="center"
				if(item[0])ctx.fillText(item[1], a%7*70+240,Math.floor(a/7)*70+300)
				
				//Pickup
				var touch = pickup("storage")
				if (click[0]&&touch!==-2) {
					var tempOut = objectMap[screenBonus[0]][screenBonus[1]][3].storage[touch].slice()
					objectMap[screenBonus[0]][screenBonus[1]][3].storage[touch] = out.slice()
	                                out = tempOut.slice()
				}
			}
		break;
	}
}
function update() {
	//Stop if map isnt generated
	if(times<=maxTimes)return

	//Active if you're not dead
	if (player.stats.hp>0) {
		
		//Decrease berserk
		player.berserkActive--
		player.moveCooldown = player.moveCooldown.map(a => a+1)
		var c
		
		//Calculate speed
		var speed = 10*player.stats.movementSpeed
		speed *= (keyPressed["shift"]&&player.stats.stamina>=0.25/player.stats.staminaCMult)?.6:1
		
		//Movement
		if(player.moveCooldown[0]>=speed&&keyPressed["w"]){move([0,-1]);player.moveCooldown[0]%=speed}
		if(player.moveCooldown[1]>=speed&&keyPressed["a"]){move([-1,0]);player.moveCooldown[1]%=speed}
		if(player.moveCooldown[2]>=speed&&keyPressed["s"]){move([0, 1]);player.moveCooldown[2]%=speed}
		if(player.moveCooldown[3]>=speed&&keyPressed["d"]){move([1, 0]);player.moveCooldown[3]%=speed}
	        
		//Smooth movement
		player.fractionalPos[0] = player.moveCooldown[3]/speed-player.moveCooldown[1]/speed
		player.fractionalPos[1] = player.moveCooldown[2]/speed-player.moveCooldown[0]/speed  
		let x=-40
		while (x <= 40) {
		        let y = -40
		        while (y <= 40) {
		        	let x2 = player.pos[0] + x
				let y2 = player.pos[1] + y  
				
				//Object out of HP
				if (objectMap[x2][y2][1] <= 0&&objectMap[x2][y2][0]) {

					//Spawn items based on loot table
                                        spawnItems(lootTables[objectMap[x2][y2][0]], 1, x2+0.5, y2+0.5)
					
					//Special cases
					switch (objectMap[x2][y2][0]) {
                                                case 25: //Chests
						case 26:
						        var a
						        for (a in objectMap[x2][y2][3].storage) {
							        var rad = Math.random()*Math.PI*2
			                                        var speed = Math.random()*0.1
								var loot = objectMap[x2][y2][3].storage[a]
			                                        drops.push({
				                                        id: loot[0],
				                                        x: x+0.5,
				                                        y: y+0.5,
				                                        dx: Math.sin(rad)*speed,
				                                        dy: Math.cos(rad)*speed,
				                                        friction: 0.97,
				                                        amount: 1,
				                                        life: loot[1], 
			                                        })
						        }
						break;
					}
                                        
					//Reset the object
					objectMap[x2][y2] = [0,0,0,{},0]
				}
		        	y++
		        }
		        x++
	        }

		//Update several things
		updateStats()
		updateTime()
		updateInventory()
		updateClick()
		
		//Pickup
		if (click[0]) pickup("inventory")

		//Stamina update
                if (keyPressed["shift"]) {
			player.stats.stamina=Math.max(player.stats.stamina-0.25*player.stats.staminaCMult,0)
		} else {
			player.stats.stamina=Math.min(player.stats.stamina+0.25,100)
		}

		//Attack update
		player.attackCooldown < 80 ? player.attackCooldown+=player.stats.attackSpeed*items[inventory[holding][0]].atkSpeed : 0
		
		//Attack action
		if (mouseDown[0]&&player.attackCooldown>=80&&screen=="") {
			player.attackCooldown %= 80
			attackDuration = 5	
			attack()
		}

		//testing
		/*if (mouseDown[0]) {
                        var rotation = Math.atan2(mousePos.x-450,mousePos.y-330)
	                var wx = Math.sin(rotation)
	                var wy = Math.cos(rotation)
	                projs.push(new Projectile(player.pos[0]+.5,player.pos[1]+.5,wx,wy,-rotation+Math.PI,1,["object","enemies"],200,100))
		}*/
		
		//Level up
		levelUp()

		//Render
	        render()   
	} else {
		//You ded!
		alert("yuo ded \n reload for new world")
	}
}
function updateBrightness() {
	var x=-40
	while (x<=40) {
                var y=-40
	        while (y<=40) {
			var x1 = x+player.pos[0]
			var y1 = y+player.pos[1]

			//In bounds
			if (x1<map.length&&x1>-1&&y1<map.length&&y1>-1) {
				//Base brightness
			        brightnessMap[x1][y1] = (Math.cos(hr*Math.PI/12+Math.PI)+1.1)/2.1        
		        }
		        y++
	        }
		x++
	}
	//Brightness from objects
	var x=-40
	while (x<=40) {
                var y=-40
	        while (y<=40) {
			var x1 = x+player.pos[0]
			var y1 = y+player.pos[1]

			//In bounds
			if (x1<map.length&&x1>-1&&y1<map.length&&y1>-1) {
                                
				//Torch / Furnace
				if (objectMap[x1][y1][0]==15||objectMap[x1][y1][0]==23) {
		                        var x2 = -20
		                        while (x2<=20) {
			                        var y2 = -20
                                                while (y2<=20) {
				                        var x3 = x1+x2
				                        var y3 = y1+y2
				                        if (x3<map.length&&x3>-1&&y3<map.length&&y3>-1) {
					                        brightnessMap[x3][y3] += Math.min((Math.random()*0.05+0.95)/(x2**2+y2**2)*2,0.4)
				                        }
				                        y2++
			                        }
			                        x2++
	                         	} 
	                        }
		        }
		        y++
	        }
		x++
	}
}
function updateInventory() {
	
	//Amounts and index
	var amounts=Array(items.length).fill(0),IndxOnInv=Array(items.length).fill(-1)
 
	//Update values
	for (c in inventory) {
	        if(c>34)break;
		if (inventory[c][1]>0) {
                        amounts[inventory[c][0]] += inventory[c][1]
		        IndxOnInv[inventory[c][0]] = c
		        unlocked[inventory[c][0]] = true
		} 
	}
	var tempArmor = inventory[35]
        inventory = Array(35).fill([0,0]).map(copy)
	inventory.push(tempArmor.slice(0))

	//Update inventory
	for (c in IndxOnInv) {
                if (IndxOnInv[c]>-1) {
			inventory[IndxOnInv[c]][0] = c*1
			inventory[IndxOnInv[c]][1] = amounts[c]
		}
	 }
}
function updateStats() {
	var baseStats = {
		hp: player.stats.hp,
		mhp: 100,
		stamina: player.stats.stamina,
		staminaCMult: 1,
		movementSpeed: 1,
		defense: 0,
		attackSpeed: 1,
		reach: 40,
		critChance: 5,
		critDamage: 140,
		inventorySlots: 14,
		regen: 0,
	}
	//drive
	var b = []
	//Set boosts
	b[0] = player.stats.hp/player.stats.mhp<player.powerups.drive/(10+player.powerups.drive) ? player.powerups.drive**0.4 : 0
        b[1] = player.powerups.berserkActive>0?Math.log(player.powerups.berserk):0
	b[2] = player.powerups.rubyPower
	
	//From powerups/armor
	baseStats.defense        += items[inventory[35][0]].defense
	baseStats.defense        += items[inventory[35][1]].defense
	baseStats.defense        += items[inventory[35][2]].defense
	baseStats.defense        += items[inventory[35][3]].defense
	baseStats.inventorySlots += player.powerups.box*2
	baseStats.critDamage     += player.powerups.rock*8+b[1]*2
	baseStats.attackSpeed    += player.powerups.milk1*0.045+b[1]/2
	baseStats.defense        *= player.powerups.milk2*0.05+b[2]/100+1
	baseStats.reach          += player.powerups.glove*4
	baseStats.critChance     += player.powerups.clover1*10+b[2]/1000
	baseStats.staminaCMult   *= 3/(player.powerups.milk3+3)*10000/(b[2]+10000)
	baseStats.movementSpeed  *= 5/(player.powerups.ring+5)*10000/(b[2]+10000)
        baseStats.mhp            += player.powerups.pill*20+b[2]
	baseStats.regen          += player.powerups.milk4*0.02
        
	//Boosts
	baseStats.defense *= b[0]+1
	baseStats.critDamage *= b[0]/1.4+1
	baseStats.attackSpeed *= b[0]/3+1
	baseStats.reach += b[0]*1.3+1
	baseStats.critChance += b[0]+1
	baseStats.staminaCMult /= b[0]/2+1
	baseStats.regen *= b[0]+1

	//Regen
	baseStats.hp = Math.min(baseStats.regen+baseStats.hp,baseStats.mhp)
	
	//Set stats
	player.stats = baseStats
}
function updateTime() {
	//Increment time
        hr += 0.002

	//No floating point precision error
	hr = hr.toFixed(4)
	
	//Spawn enemies if night and every 30 mins
	if(!(hr*1000%500)&&hr<6)spawnEnemies()
	
	//Update day
	hr %= 24
	if (hr==0) day++

	//Calculate difficulty
	diff = 1.1**day*Math.sqrt(diffMult)

	//Damage monster if it's past 8:00
	if (hr>=8) {
		for (let n in enemies) {
			enemies[n].hp -= enemies[n].mhp/500/Math.sqrt(diffMult)
		}
	}
}
function showDetails() {

	//Do not do anything if screen is not inventory
	if (screen!=="inventory")return

	var touched = -2

	//Hotbar
        if (mousePos.y>=530&&mousePos.x<500&&mousePos.y<=590) {
                if (mousePos.x%70-9>0) {
			touched = Math.floor(mousePos.x/70)
		}
	} 
	
	//Inventory
	else if (mousePos.y>=95&&mousePos.x>=65&&(mousePos.y%70<15||mousePos.y%70>24)&&(mousePos.x+5)%70<60&&mousePos.x<=644&&mousePos.y<=444&&screen=="inventory") {
                touched = Math.floor((mousePos.x-65)/70)+(4-Math.floor((mousePos.y-95)/70))*7
	}
	
	//If touched isnt [REDACTED] and it's not outside inventory
	if(touched!==-2&&touched<player.stats.inventorySlots) {
               
		//Rarity
		ctx.fillStyle = rarity_colors[items[inventory[touched][0]].rarity]
		ctx.fillRect(640, 95, 60, 60)
		
		//Draw it
		ctx.drawImage(sprite.items, inventory[touched][0]%5*60, Math.floor(inventory[touched][0]/5)*60, 60, 60, 640, 95, 60, 60)
		
	        //Font	
		ctx.fillStyle = "#fff"
		ctx.font = Math.floor(240/(items[inventory[touched][0]].name.length))+"px Roboto"
		
		//Name
		ctx.fillText(items[inventory[touched][0]].name,765,125)
		
		//Damage amount
		ctx.font = "18px Roboto"
		ctx.textAlign = "left"
		wrapText("Damage: "+items[inventory[touched][0]].minDamage+" - "+items[inventory[touched][0]].maxDamage, 640, 170, 185, 17)
	        
		//Rarity
		ctx.fillText("Rarity:", 640, 190, 185, 17)	
		ctx.fillStyle=rarity_colors[items[inventory[touched][0]].rarity];ctx.fillText(items[inventory[touched][0]].rarity.toUpperCase(), 694, 190)
		
		//Description
		ctx.fillStyle="#fff"      
		wrapText("Description: "+items[inventory[touched][0]].desc, 640, 210, 185, 17)
	}
}
function spawnEnemies() {
	
	//Spawning variables
	var spwnPower = (Math.log(day)+1)*3*Math.random()*Math.cbrt(diffMult)
	console.log(spwnPower)
	var spawnable = {
		"zombie": 2,
		"skeleton": 2,
	}

	//Prevents infinite loop
	var n = 100
	while (n > 0) {

		//Find type to spawn
		var spawn = anti_weighted_random(spawnable)
		if (spawnable[spawn]<=spwnPower) {

			n = 100
			spwnPower -= spawnable[spawn]

			//Find spawn position
			var spawnPos = [Math.floor(Math.random()*70)-35+player.pos[0],Math.floor(Math.random()*70)-35+player.pos[1]]
		        while (spawnPos[0]<0||spawnPos[0]>=map.length||spawnPos[1]<0||spawnPos[1]>=map.length) {
				spawnPos = [Math.floor(Math.random()*70)-35+player.pos[0],Math.floor(Math.random()*70)-35+player.pos[1]]
			}
			//20 spawning attempts       
			var a = 20       
			while (objectMap[spawnPos[0]][spawnPos[1]][0]&&a--) {
				spawnPos = [Math.floor(Math.random()*70)-35+player.pos[0],Math.floor(Math.random()*70)-35+player.pos[1]]
			}
			if (a>0) {

				//Get mob to spawn
				var toSpawn = getMobs(spawn,spawnPos[0],spawnPos[1])

				//Spawn
				enemies.push(toSpawn)
			}
		} else {
			n--
		}
	}
}
function spawnItems(lootTable, times, x, y) {
	var loots = [],a,c=0
	//loottable format: [id n, chance n] or [id n, min n, max n]
	
	//Go through loot table and add to the list of items to spawn
	while (c++ < times) {
	        for (a in lootTable) {
		        switch (lootTable[a].length) {

				//Chance table
			        case 2:
                                        if (Math.random()<lootTable[a][1]/100) {
				        	loots.push( [lootTable[a][0], 1] )
			        	}
		        	break;

				//Amount table
		        	case 3:
			        	loots.push( [lootTable[a][0], Math.round(randomRange(lootTable[a][1], lootTable[a][2]))] )
		        	break;
	        	}
        	}
        }

	//Spawn items
	for (a in loots) {
		while (loots[a][1]--) {
			var rad = Math.random()*Math.PI*2
			var speed = Math.random()*0.1
			drops.push({
				id: loots[a][0],
				x: x+0.5,
				y: y+0.5,
				dx: Math.sin(rad)*speed,
				dy: Math.cos(rad)*speed,
				friction: 0.97,
				amount: 1,
				life: 7, 
			})
		}
	}
}
function loadData() {
	var save = JSON.parse(localStorage.survive)
	if (save) return
	var baseSave = {
                achv: Array(1024).fill(true)
	}
}
class Projectile {
	constructor (x,y,dx,dy,rotation,damage,canDamage,life,pierce) {
                this.x = x
		this.y = y
		this.dx = dx
		this.dy = dy
		this.rotation = rotation
		this.damage = damage
		this.canDamage = canDamage
		this.tick = function() {
			
			//Movement
			var distToMove = this.dx**2+this.dy**2
			var vRotation = Math.atan2(this.dx,this.dy)
			var rx = Math.floor(this.x)
			var ry = Math.floor(this.y)
			var collided

			//Bullet marching 
			while (distToMove>0&&!collided) {
				var minDist = Infinity,n
				if (this.canDamage.indexOf("enemies")>-1) {
                                        for (n in enemies) {
						if(collided)break
						        
						//Setting min distance
						var dist = get2DistToCircle(this.x,this.y,enemies[n].x,enemies[n].y,Math.SQRT1_2*1.5,0)
						minDist = Math.min(dist,minDist)

						//Collision
						if (dist<=0) {
                                                        collided = n*1
						}
					}
				}
				if (this.canDamage.indexOf("object")>-1) {

					//Find the check range
					var n=Math.ceil(Math.sqrt(distToMove))
					var x=-n
					while (x<=n&&!collided) {
						var y = -n
						while (y<=n&&!collided) {

							//Prevents infinite loop
							var x2 = x+rx , y2 = y+ry
							y++
							if (!objectMap[x2][y2][0]) continue

							//Distance shenanigans
                                                        var dist = get2DistToCircle(this.x,this.y,x2+.5,y2+.5,Math.SQRT1_2*1.5,0)
						        minDist = Math.min(minDist,dist)

							//Collision
							if (dist<=0) {
								collided = [x2,y2]
							}       
						}
					        x++
					}
				}
				if (this.canDamage.indexOf("player")>-1) {
					if (!collided) {
						//Yes
						var dist = get2DistToCircle(this.x,this.y,player.pos[0]+.5,player.pos[1]+.5,Math.SQRT1_2*1.5,0)
						minDist = Math.min(minDist,dist)

						//Dist<=0 -> collided
						if (dist<=0) {
							collided = "player"
						}
					}
				}

				//Set minDist
				minDist = Math.max(0,Math.min(distToMove,minDist))
				distToMove -= minDist
				minDist = Math.sqrt(minDist)

				//Movement
				this.x += Math.sin(vRotation)*minDist
				this.y += Math.cos(vRotation)*minDist
			}

			//Less life :(
			this.life--

			//Damaging
			switch (typeof collided) {
				
				//Player
				case "string":
				        var damage = this.damage*100/(player.stats.defense+100)
	                                player.stats.hp = Math.max(0,player.stats.hp-damage)
				break;

				//Enemies
				case "number":
				        enemies[collided].hp -= this.damage
				break;

				//Objects
				case "object":
					objectMap[collided[0]][collided[1]][1] -= this.damage
				break;
			}		
		
		        //Destroy the proj on hit
			this.life = collided?0:this.life
		}
		this.life = life
	}
}
</script>
</html>